#!/usr/bin/python
 
import spidev
import time
import os
import sys
import RPi.GPIO as GPIO

#Use GPIO pin numbering
GPIO.setmode(GPIO.BCM)

#Set pin number
resetPin = 22
fPin = 23
stopPin = 24
displayPin = 25
SPICLK = 11
SPIMISO = 9
SPIMOSI = 10
SPICS = 8

#Pull up mode
GPIO.setup(resetPin,GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(fPin,GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(stopPin,GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(displayPin,GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(SPICLK, GPIO.OUT)
GPIO.setup(SPIMISO, GPIO.OUT)
GPIO.setup(SPIMOSI, GPIO.OUT)
GPIO.setup(SPICS, GPIO.OUT)

#global variable

#Define Variables
f = 0.5

#FIND OUT
ldr_channel = 0

#Open SPI bus
spi = spidev.SpiDev()
#create spi object
spi.open(0, 0)  

#Read data from ADC channel
def getData(adcvalue):
  # read SPI data from the MCP3008, 8 channels in total
  if adcvalue>7 or adcvalue<0:
    return -1
  adc = spi.xfer2([1,(8+adcvalue)<<4,0])
  data = ((adc[1]&3)<<8)+adc[2]
  return data

#Convert data to voltage level
def convertVolts(data,places):
  volts = (data*3.3)/float(1023)
  volts = round(volts,places)
  return volts
  
#function definition: threaded callback
def callbackReset(channel):
  #code
def callbackf(channel):
  #code
def callbackStop(channel):
  #code
def callbackDisplay(channel):
  #code
  
#Under a falling-edge detection, regardless of current execution
#callback function will be called
GPIO.add_event_detect(resetPin, GPIO.FALLING, callback=callbackReset, bouncetime=200)
GPIO.add_event_detect(fPin, GPIO.FALLING, callback=callbackf, buncetime=200)
GPIO.add_event_detect(stopPin, GPIO.FALLING, callback=callbackStop, bouncetime=200)
GPIO.add_event_detect(displayPin, GPIO.FALLING, callback=callbackDisplay, buncetime=200)

#'bouncetime=200' includes the bounce control
#'bouncetime=200' sets 200 ms during whicj second button press will be ignored
#to remove: GPIO.remove_event_detect(port_number)

#Define sensor channels
channel = 0
#Define delay between readings
delay = .5

try:
  while True:
  
    GPIO.wait_for_edge(resetPin, GPIO.RISING)
    GPIO.wait_for_edge(fPin, GPIO.RISING)
    GPIO.wait_for_edge(stopPin, GPIO.RISING)
    GPIO.wait_for_edge(displayPin, GPIO.RISING)
    
    #Read the data
    sensor_data = getData(channel)
    sensor_volt = convertVolts(sensor_data,2)
    #Wait before repeating loop
    time.sleep(f)

except keyboardInterrupt:
  spi.close()
  #Clean up GPIO on CTRL+C exit
  GPIO.cleanup()
GPIO.cleanup()
